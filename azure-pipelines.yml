# Azure DevOps Pipeline for Sports Coaching Platform
# Builds, tests, and deploys 3 microservices to Azure Web Apps

trigger:
  - main

pool:
  name: 'self-hosted'

variables:
  # Name of Azure DevOps Service Connection (Project settings -> Service connections)
  azureSubscription: 'sc-azure-sdc'

  # Azure resource names
  resourceGroup: 'sdc-resource-group'
  coachServiceName: 'sdc-coach-service'
  sessionServiceName: 'sdc-session-service'
  reviewServiceName: 'sdc-review-service'

  # Override these if your App Service default hostnames differ from <app>.azurewebsites.net
  coachHost: '$(coachServiceName).azurewebsites.net'
  sessionHost: '$(sessionServiceName).azurewebsites.net'
  reviewHost: '$(reviewServiceName).azurewebsites.net'

  # If your App Service Plan is Windows, set to webApp.
  # If Linux, set to webAppLinux.
  appType: 'webAppLinux'

  # Health endpoint (services expose /health)
  healthPath: '/health'

  # Note: Using azureSubscription service connection for authentication
  # Publish profiles are not needed when service connection is configured

stages:
  # Stage 1: Build and Test
  - stage: Build
    displayName: 'Build and Test'
    jobs:
      - job: BuildAndTest
        displayName: 'Build, Test, and Package'
        steps:
          - script: |
              set -e
              echo "OS info:"
              uname -a || true
              echo "Java version:"
              java -version
              echo "Maven version:"
              mvn -version
            displayName: 'Display build environment'

          # One command is faster + more deterministic
          - script: |
              set -e
              mvn -B clean test package
            displayName: 'Build + run unit tests + package'

          - task: PublishTestResults@2
            displayName: 'Publish JUnit test results'
            condition: succeededOrFailed()
            inputs:
              testResultsFormat: 'JUnit'
              testResultsFiles: '**/target/surefire-reports/TEST-*.xml'
              failTaskOnFailedTests: true
              testRunTitle: 'Unit Tests'

          # Collect jars (exclude sources/javadoc/original)
          - task: CopyFiles@2
            displayName: 'Copy coach-service JAR'
            inputs:
              sourceFolder: 'coach-service/target'
              contents: |
                *.jar
                !*sources.jar
                !*javadoc.jar
                !original-*.jar
              targetFolder: '$(Build.ArtifactStagingDirectory)/coach-service'
              flattenFolders: true

          - task: CopyFiles@2
            displayName: 'Copy session-service JAR'
            inputs:
              sourceFolder: 'session-service/target'
              contents: |
                *.jar
                !*sources.jar
                !*javadoc.jar
                !original-*.jar
              targetFolder: '$(Build.ArtifactStagingDirectory)/session-service'
              flattenFolders: true

          - task: CopyFiles@2
            displayName: 'Copy review-service JAR'
            inputs:
              sourceFolder: 'review-service/target'
              contents: |
                *.jar
                !*sources.jar
                !*javadoc.jar
                !original-*.jar
              targetFolder: '$(Build.ArtifactStagingDirectory)/review-service'
              flattenFolders: true

          - task: PublishBuildArtifacts@1
            displayName: 'Publish build artifacts'
            inputs:
              pathToPublish: '$(Build.ArtifactStagingDirectory)'
              artifactName: 'services'
              publishLocation: 'Container'

  # =============================================================================
  # Stage 2: Deploy to Azure Web Apps
  # =============================================================================
  - stage: Deploy
    displayName: 'Deploy to Azure'
    dependsOn: Build
    condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))
    jobs:
      # Using normal jobs instead of "deployment + environment"
      # avoids environment-approval / permission prompts in many setups.
      - job: DeployCoachService
        displayName: 'Deploy Coach Service'
        steps:
          - download: current
            artifact: services

          - task: AzureWebApp@1
            displayName: 'Deploy coach-service to Azure Web App'
            inputs:
              azureSubscription: '$(azureSubscription)'
              appType: '$(appType)'
              appName: '$(coachServiceName)'
              package: '$(Pipeline.Workspace)/services/coach-service/*.jar'

      - job: DeploySessionService
        displayName: 'Deploy Session Service'
        dependsOn: DeployCoachService
        steps:
          - download: current
            artifact: services

          - task: AzureWebApp@1
            displayName: 'Deploy session-service to Azure Web App'
            inputs:
              azureSubscription: '$(azureSubscription)'
              appType: '$(appType)'
              appName: '$(sessionServiceName)'
              package: '$(Pipeline.Workspace)/services/session-service/*.jar'

      - job: DeployReviewService
        displayName: 'Deploy Review Service'
        dependsOn: DeploySessionService
        steps:
          - download: current
            artifact: services

          - task: AzureWebApp@1
            displayName: 'Deploy review-service to Azure Web App'
            inputs:
              azureSubscription: '$(azureSubscription)'
              appType: '$(appType)'
              appName: '$(reviewServiceName)'
              package: '$(Pipeline.Workspace)/services/review-service/*.jar'

  # =============================================================================
  # Stage 3: Post-Deployment Verification
  # =============================================================================
  - stage: Verify
    displayName: 'Verify Deployment'
    dependsOn: Deploy
    condition: succeeded()
    jobs:
      - job: HealthCheck
        displayName: 'Health Check Services'
        steps:
          - task: AzureCLI@2
            displayName: 'Resolve App Service hostnames + verify state'
            inputs:
              azureSubscription: '$(azureSubscription)'
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                set -euo pipefail
                echo "Checking App Service state in resource group: $(resourceGroup)"

                resolve_app() {
                  local name="$1"
                  local var_name="$2"
                  local state
                  local host
                  state="$(az webapp show --resource-group "$(resourceGroup)" --name "$name" --query state -o tsv)"
                  host="$(az webapp show --resource-group "$(resourceGroup)" --name "$name" --query defaultHostName -o tsv)"
                  echo "App Service $name state: $state"
                  if [ "$state" != "Running" ]; then
                    echo "Expected $name to be Running, got: $state"
                    exit 1
                  fi
                  echo "Resolved hostname for $name: $host"
                  echo "##vso[task.setvariable variable=${var_name}]$host"
                }

                resolve_app "$(coachServiceName)" "coachHost"
                resolve_app "$(sessionServiceName)" "sessionHost"
                resolve_app "$(reviewServiceName)" "reviewHost"

          - script: |
              set -e
              echo "Waiting for services to start (Java apps need ~3-4 minutes)..."
              sleep 180

              check_health() {
                local name="$1"
                local url="$2"
                echo "Checking $name health at $url..."
                curl -sf --retry 15 --retry-delay 15 --retry-all-errors --max-time 30 "$url" && echo " OK" || {
                  echo "FAILED: $name health check"
                  return 1
                }
              }

              check_health "Coach Service" "https://$(coachHost)$(healthPath)"
              check_health "Session Service" "https://$(sessionHost)$(healthPath)"
              check_health "Review Service" "https://$(reviewHost)$(healthPath)"

              echo ""
              echo "All services are healthy!"
            displayName: 'Verify service health endpoints'
